autofs-5.1.7 - eliminate some more alloca usage

From: Ian Kent <raven@themaw.net>

Quite a bit of the alloca(3) usage has been eliminated over time.
Use malloc(3) for some more cases that might need to allocate a largish
amount of storage.

Signed-off-by: Ian Kent <raven@themaw.net>
---
 CHANGELOG                |    1 +
 modules/lookup_program.c |   11 ++++++++++-
 modules/lookup_yp.c      |   22 +++++++++++++++++++---
 modules/parse_sun.c      |   18 ++++++++++++++----
 modules/replicated.c     |   19 ++++++-------------
 5 files changed, 50 insertions(+), 21 deletions(-)

--- autofs-5.1.4.orig/CHANGELOG
+++ autofs-5.1.4/CHANGELOG
@@ -143,6 +143,7 @@
 - eliminate buffer usage from handle_mounts_cleanup().
 - fix possible use after free in handle_mounts_exit().
 - make submount cleanup the same as top level mounts.
+- eliminate some more alloca usage.
 
 xx/xx/2018 autofs-5.1.5
 - fix flag file permission.
--- autofs-5.1.4.orig/modules/lookup_program.c
+++ autofs-5.1.4/modules/lookup_program.c
@@ -651,7 +651,14 @@ int lookup_mount(struct autofs_point *ap
 			char *ent = NULL;
 
 			if (me->mapent) {
-				ent = alloca(strlen(me->mapent) + 1);
+				ent = malloc(strlen(me->mapent) + 1);
+				if (!ent) {
+					char buf[MAX_ERR_BUF];
+					char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
+					error(ap->logopt, MODPREFIX "malloc: %s", estr);
+					cache_unlock(mc);
+					goto out_free;
+				}
 				strcpy(ent, me->mapent);
 			}
 			cache_unlock(mc);
@@ -659,6 +666,8 @@ int lookup_mount(struct autofs_point *ap
 			ap->entry->current = source;
 			ret = ctxt->parse->parse_mount(ap, name,
 				 name_len, ent, ctxt->parse->context);
+			if (ent)
+				free(ent);
 			goto out_free;
 		} else {
 			if (IS_MM(me) && !IS_MM_ROOT(me)) {
--- autofs-5.1.4.orig/modules/lookup_yp.c
+++ autofs-5.1.4/modules/lookup_yp.c
@@ -254,7 +254,7 @@ int yp_all_master_callback(int status, c
 
 	len = ypkeylen + 1 + vallen + 2;
 
-	buffer = alloca(len);
+	buffer = malloc(len);
 	if (!buffer) {
 		error(logopt, MODPREFIX "could not malloc parse buffer");
 		return 0;
@@ -267,6 +267,8 @@ int yp_all_master_callback(int status, c
 
 	master_parse_entry(buffer, timeout, logging, age);
 
+	free(buffer);
+
 	return 0;
 }
 
@@ -368,7 +370,12 @@ int yp_all_callback(int status, char *yp
 		return 0;
 	}
 
-	mapent = alloca(vallen + 1);
+	mapent = malloc(vallen + 1);
+	if (!mapent) {
+		error(logopt, MODPREFIX "could not malloc mapent buffer");
+		free(key);
+		return 0;
+	}
 	strncpy(mapent, val, vallen);
 	*(mapent + vallen) = '\0';
 
@@ -377,6 +384,7 @@ int yp_all_callback(int status, char *yp
 	cache_unlock(mc);
 
 	free(key);
+	free(mapent);
 
 	if (ret == CHE_FAIL)
 		return -1;
@@ -922,7 +930,14 @@ int lookup_mount(struct autofs_point *ap
 		}
 		if (me && (me->source == source || *me->key == '/')) {
 			mapent_len = strlen(me->mapent);
-			mapent = alloca(mapent_len + 1);
+			mapent = malloc(mapent_len + 1);
+			if (!mapent) {
+				char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
+				error(ap->logopt, MODPREFIX "malloc: %s", estr);
+				cache_unlock(mc);
+				free(lkp_key);
+				return NSS_STATUS_TRYAGAIN;
+			}
 			strcpy(mapent, me->mapent);
 		}
 	}
@@ -947,6 +962,7 @@ int lookup_mount(struct autofs_point *ap
 
 	ret = ctxt->parse->parse_mount(ap, key, key_len,
 				       mapent, ctxt->parse->context);
+	free(mapent);
 	if (ret) {
 		/* Don't update negative cache when re-connecting */
 		if (ap->flags & MOUNT_FLAG_REMOUNT)
--- autofs-5.1.4.orig/modules/parse_sun.c
+++ autofs-5.1.4/modules/parse_sun.c
@@ -672,9 +672,16 @@ static int sun_mount(struct autofs_point
 		}
 	}
 
+	what = malloc(loclen + 1);
+	if (!what) {
+		char buf[MAX_ERR_BUF];
+		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
+		error(ap->logopt, MODPREFIX "malloc: %s", estr);
+		return 1;
+	}
+
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cur_state);
 	if (!strcmp(fstype, "nfs") || !strcmp(fstype, "nfs4")) {
-		what = alloca(loclen + 1);
 		memcpy(what, loc, loclen);
 		what[loclen] = '\0';
 
@@ -710,10 +717,10 @@ static int sun_mount(struct autofs_point
 		rv = mount_nfs->mount_mount(ap, root, name, namelen,
 					    what, fstype, options, mount_nfs->context);
 	} else {
-		if (!loclen)
+		if (!loclen) {
+			free(what);
 			what = NULL;
-		else {
-			what = alloca(loclen + 1);
+		} else {
 			if (*loc == ':') {
 				loclen--;
 				memcpy(what, loc + 1, loclen);
@@ -732,6 +739,9 @@ static int sun_mount(struct autofs_point
 		/* Generic mount routine */
 		rv = do_mount(ap, root, name, namelen, what, fstype, options);
 	}
+	if (what)
+		free(what);
+
 	pthread_setcancelstate(cur_state, NULL);
 
 	if (nonstrict && rv)
--- autofs-5.1.4.orig/modules/replicated.c
+++ autofs-5.1.4/modules/replicated.c
@@ -1044,25 +1044,18 @@ done:
 	return ret;
 }
 
-static int add_path(struct host *hosts, const char *path, int len)
+static int add_path(struct host *hosts, const char *path)
 {
 	struct host *this;
-	char *tmp, *tmp2;
-
-	tmp = alloca(len + 1);
-	if (!tmp)
-		return 0;
-
-	strncpy(tmp, path, len);
-	tmp[len] = '\0';
+	char *tmp;
 
 	this = hosts;
 	while (this) {
 		if (!this->path) {
-			tmp2 = strdup(tmp);
-			if (!tmp2)
+			tmp = strdup(path);
+			if (!tmp)
 				return 0;
-			this->path = tmp2;
+			this->path = tmp;
 		}
 		this = this->next;
 	}
@@ -1191,7 +1184,7 @@ int parse_location(unsigned logopt, stru
 						}
 					}
 
-					if (!add_path(*hosts, path, strlen(path))) {
+					if (!add_path(*hosts, path)) {
 						free_host_list(hosts);
 						free(str);
 						return 0;
