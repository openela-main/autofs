autofs-5.1.8 - add soucre parameter to module functions

From: Ian Kent <raven@themaw.net>

There's a unnecessarily complicated method used to pass the map source
to module read map and lookup mount functions. This also confuses
coverity which constantly complains about unmatched locking.

Just add a parameter to those functions to simplify it and elliminate
the coverity false positives not to mention slightly less overhead by
the lock removal.

Signed-off-by: Ian Kent <raven@themaw.net>
---
 CHANGELOG                 |    1 
 daemon/lookup.c           |   10 +------
 daemon/master.c           |   57 ----------------------------------------
 include/automount.h       |   16 ++++++-----
 include/master.h          |    4 --
 modules/lookup_dir.c      |    8 +----
 modules/lookup_file.c     |   29 +++++---------------
 modules/lookup_hesiod.c   |   15 ++--------
 modules/lookup_hosts.c    |   36 +++++++------------------
 modules/lookup_ldap.c     |   35 ++++++++-----------------
 modules/lookup_multi.c    |   24 ++++-------------
 modules/lookup_nisplus.c  |   27 +++++--------------
 modules/lookup_program.c  |   29 +++++---------------
 modules/lookup_sss.c      |   64 ++++++++++------------------------------------
 modules/lookup_userhome.c |   16 ++---------
 modules/lookup_yp.c       |   35 ++++++++-----------------
 modules/parse_amd.c       |   16 +++--------
 modules/parse_hesiod.c    |    8 ++---
 modules/parse_sun.c       |   15 +++-------
 19 files changed, 112 insertions(+), 333 deletions(-)

--- autofs-5.1.4.orig/CHANGELOG
+++ autofs-5.1.4/CHANGELOG
@@ -144,6 +144,7 @@
 - fix possible use after free in handle_mounts_exit().
 - make submount cleanup the same as top level mounts.
 - eliminate some more alloca usage.
+- add soucre parameter to module functions.
 
 xx/xx/2018 autofs-5.1.5
 - fix flag file permission.
--- autofs-5.1.4.orig/daemon/lookup.c
+++ autofs-5.1.4/daemon/lookup.c
@@ -361,13 +361,10 @@ static int do_read_map(struct autofs_poi
 		map_module_unlock(map);
 	}
 
-	master_source_current_wait(ap->entry);
-	ap->entry->current = map;
-
 	pthread_cleanup_push(map_module_lock_cleanup, map);
 	map_module_readlock(map);
 	lookup = map->lookup;
-	status = lookup->lookup_read_map(ap, age, lookup->context);
+	status = lookup->lookup_read_map(ap, map, age, lookup->context);
 	pthread_cleanup_pop(1);
 
 	if (status != NSS_STATUS_SUCCESS)
@@ -837,12 +834,9 @@ int do_lookup_mount(struct autofs_point
 		map_module_unlock(map);
 	}
 
-	master_source_current_wait(ap->entry);
-	ap->entry->current = map;
-
 	map_module_readlock(map);
 	lookup = map->lookup;
-	status = lookup->lookup_mount(ap, name, name_len, lookup->context);
+	status = lookup->lookup_mount(ap, map, name, name_len, lookup->context);
 	map_module_unlock(map);
 
 	return status;
--- autofs-5.1.4.orig/daemon/master.c
+++ autofs-5.1.4/daemon/master.c
@@ -682,47 +682,6 @@ void master_source_lock_cleanup(void *ar
 	return;
 }
 
-void master_source_current_wait(struct master_mapent *entry)
-{
-	int status;
-
-	status = pthread_mutex_lock(&entry->current_mutex);
-	if (status) {
-		logmsg("entry current source lock failed");
-		fatal(status);
-	}
-
-	while (entry->current != NULL) {
-		status = pthread_cond_wait(
-				&entry->current_cond, &entry->current_mutex);
-		if (status) {
-			logmsg("entry current source condition wait failed");
-			fatal(status);
-		}
-	}
-
-	return;
-}
-
-void master_source_current_signal(struct master_mapent *entry)
-{
-	int status;
-
-	status = pthread_cond_signal(&entry->current_cond);
-	if (status) {
-		logmsg("entry current source condition signal failed");
-		fatal(status);
-	}
-
-	status = pthread_mutex_unlock(&entry->current_mutex);
-	if (status) {
-		logmsg("entry current source unlock failed");
-		fatal(status);
-	}
-
-	return;
-}
-
 struct master_mapent *master_find_mapent(struct master *master, const char *path)
 {
 	struct list_head *head, *p;
@@ -845,14 +804,6 @@ struct master_mapent *master_new_mapent(
 	if (status)
 		fatal(status);
 
-	status = pthread_mutex_init(&entry->current_mutex, NULL);
-	if (status)
-		fatal(status);
-
-	status = pthread_cond_init(&entry->current_cond, NULL);
-	if (status)
-		fatal(status);
-
 	INIT_LIST_HEAD(&entry->list);
 
 	return entry;
@@ -920,14 +871,6 @@ void master_free_mapent(struct master_ma
 	if (status)
 		fatal(status);
 
-	status = pthread_mutex_destroy(&entry->current_mutex);
-	if (status)
-		fatal(status);
-
-	status = pthread_cond_destroy(&entry->current_cond);
-	if (status)
-		fatal(status);
-
 	free(entry);
 
 	return;
--- autofs-5.1.4.orig/include/automount.h
+++ autofs-5.1.4/include/automount.h
@@ -281,15 +281,15 @@ int lookup_source_close_ioctlfd(struct a
 int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **context);
 int lookup_reinit(const char *mapfmt, int argc, const char *const *argv, void **context);
 int lookup_read_master(struct master *master, time_t age, void *context);
-int lookup_read_map(struct autofs_point *, time_t, void *context);
-int lookup_mount(struct autofs_point *, const char *, int, void *);
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context);
+int lookup_mount(struct autofs_point *, struct map_source *map, const char *name, int name_len, void *context);
 int lookup_done(void *);
 #endif
 typedef int (*lookup_init_t) (const char *, int, const char *const *, void **);
 typedef int (*lookup_reinit_t) (const char *, int, const char *const *, void **);
 typedef int (*lookup_read_master_t) (struct master *master, time_t, void *);
-typedef int (*lookup_read_map_t) (struct autofs_point *, time_t, void *);
-typedef int (*lookup_mount_t) (struct autofs_point *, const char *, int, void *);
+typedef int (*lookup_read_map_t) (struct autofs_point *, struct map_source *, time_t, void *);
+typedef int (*lookup_mount_t) (struct autofs_point *, struct map_source *, const char *, int, void *);
 typedef int (*lookup_done_t) (void *);
 
 struct lookup_mod {
@@ -318,13 +318,15 @@ int close_lookup(struct lookup_mod *);
 #ifdef MODULE_PARSE
 int parse_init(int argc, const char *const *argv, void **context);
 int parse_reinit(int argc, const char *const *argv, void **context);
-int parse_mount(struct autofs_point *ap, const char *name,
-		int name_len, const char *mapent, void *context);
+int parse_mount(struct autofs_point *ap, struct map_source *map,
+		const char *name, int name_len, const char *mapent,
+		void *context);
 int parse_done(void *);
 #endif
 typedef int (*parse_init_t) (int, const char *const *, void **);
 typedef int (*parse_reinit_t) (int, const char *const *, void **);
-typedef int (*parse_mount_t) (struct autofs_point *, const char *, int, const char *, void *);
+typedef int (*parse_mount_t) (struct autofs_point *, struct map_source *,
+				const char *, int, const char *, void *);
 typedef int (*parse_done_t) (void *);
 
 struct parse_mod {
--- autofs-5.1.4.orig/include/master.h
+++ autofs-5.1.4/include/master.h
@@ -49,8 +49,6 @@ struct master_mapent {
 	time_t age;
 	struct master *master;
 	pthread_rwlock_t source_lock;
-	pthread_mutex_t current_mutex;
-	pthread_cond_t current_cond;
 	struct map_source *current;
 	struct map_source *maps;
 	struct autofs_point *ap;
@@ -106,8 +104,6 @@ void master_source_writelock(struct mast
 void master_source_readlock(struct master_mapent *);
 void master_source_unlock(struct master_mapent *);
 void master_source_lock_cleanup(void *);
-void master_source_current_wait(struct master_mapent *);
-void master_source_current_signal(struct master_mapent *);
 struct master_mapent *master_find_mapent(struct master *, const char *);
 struct autofs_point *master_find_mapent_by_devid(struct master *master, dev_t devid);
 struct master_mapent *master_new_mapent(struct master *, const char *, time_t);
--- autofs-5.1.4.orig/modules/lookup_dir.c
+++ autofs-5.1.4/modules/lookup_dir.c
@@ -225,17 +225,13 @@ int lookup_read_master(struct master *ma
 	return NSS_STATUS_SUCCESS;
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
 	return NSS_STATUS_UNKNOWN;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
 	return NSS_STATUS_UNKNOWN;
 }
 
--- autofs-5.1.4.orig/modules/lookup_file.c
+++ autofs-5.1.4/modules/lookup_file.c
@@ -689,23 +689,17 @@ prepare_plus_include(struct autofs_point
 	return new;
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	char key[KEY_MAX_LEN + 1];
 	char mapent[MAPENT_MAX_LEN + 1];
 	FILE *f;
 	unsigned int k_len, m_len;
 	int entry;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	if (source->recurse)
 		return NSS_STATUS_TRYAGAIN;
 
@@ -1128,11 +1122,11 @@ static int map_update_needed(struct auto
 	return ret;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	struct mapent *me;
 	char key[KEY_MAX_LEN + 1];
 	int key_len;
@@ -1143,12 +1137,6 @@ int lookup_mount(struct autofs_point *ap
 	int status = 0;
 	int ret = 1;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	if (source->recurse)
 		return NSS_STATUS_UNAVAIL;
 
@@ -1300,10 +1288,7 @@ do_cache_lookup:
 
 	free(lkp_key);
 
-	master_source_current_wait(ap->entry);
-	ap->entry->current = source;
-
-	ret = ctxt->parse->parse_mount(ap, key, key_len,
+	ret = ctxt->parse->parse_mount(ap, source, key, key_len,
 				       mapent, ctxt->parse->context);
 	if (ret) {
 		/* Don't update negative cache when re-connecting */
--- autofs-5.1.4.orig/modules/lookup_hesiod.c
+++ autofs-5.1.4/modules/lookup_hesiod.c
@@ -160,11 +160,8 @@ int lookup_read_master(struct master *ma
 	return NSS_STATUS_UNKNOWN;
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
 	return NSS_STATUS_UNKNOWN;
 }
 
@@ -360,11 +357,11 @@ done:
 	return ret;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
 	char buf[MAX_ERR_BUF];
-	struct map_source *source;
+	struct map_source *source = map;
 	struct mapent *me;
 	char key[KEY_MAX_LEN + 1];
 	size_t key_len;
@@ -373,10 +370,6 @@ int lookup_mount(struct autofs_point *ap
 	char *mapent;
 	int rv;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
 	debug(ap->logopt,
 	      MODPREFIX "looking up root=\"%s\", name=\"%s\"",
 	      ap->path, name);
@@ -486,7 +479,7 @@ int lookup_mount(struct autofs_point *ap
 
 	free(lkp_key);
 
-	rv = ctxt->parser->parse_mount(ap, key, key_len,
+	rv = ctxt->parser->parse_mount(ap, source, key, key_len,
 				       mapent, ctxt->parser->context);
 	free(mapent);
 
--- autofs-5.1.4.orig/modules/lookup_hosts.c
+++ autofs-5.1.4/modules/lookup_hosts.c
@@ -182,10 +182,7 @@ static int do_parse_mount(struct autofs_
 {
 	int ret;
 
-	master_source_current_wait(ap->entry);
-	ap->entry->current = source;
-
-	ret = ctxt->parse->parse_mount(ap, name, name_len,
+	ret = ctxt->parse->parse_mount(ap, source, name, name_len,
 				 mapent, ctxt->parse->context);
 	if (ret) {
 		struct mapent_cache *mc = source->mc;
@@ -312,11 +309,10 @@ next:
 		debug(ap->logopt, MODPREFIX
 		      "attempt to update exports for %s", entries->key);
 
-		master_source_current_wait(ap->entry);
-		ap->entry->current = source;
 		ap->flags |= MOUNT_FLAG_REMOUNT;
-		ret = ctxt->parse->parse_mount(ap, entries->key, strlen(entries->key),
-					       entries->entry, ctxt->parse->context);
+		ret = ctxt->parse->parse_mount(ap, source, entries->key,
+					       strlen(entries->key), entries->entry,
+					       ctxt->parse->context);
 		if (ret)
 			warn(ap->logopt, MODPREFIX
 			     "failed to parse mount %s", entries->entry);
@@ -326,20 +322,14 @@ next:
 	pthread_cleanup_pop(1);
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	struct hostent *host;
 	int status;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	debug(ap->logopt, MODPREFIX "read hosts map");
 
 	/*
@@ -381,23 +371,17 @@ int lookup_read_map(struct autofs_point
 	return NSS_STATUS_SUCCESS;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	struct mapent *me;
 	char *mapent = NULL;
 	int mapent_len;
 	time_t now = monotonic_time(NULL);
 	int ret;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	/* Check if we recorded a mount fail for this key anywhere */
 	me = lookup_source_mapent(ap, name, LKP_DISTINCT);
 	if (me) {
--- autofs-5.1.4.orig/modules/lookup_ldap.c
+++ autofs-5.1.4/modules/lookup_ldap.c
@@ -83,6 +83,8 @@ struct ldap_search_params {
 
 static int decode_percent_hack(const char *, char **);
 
+pthread_mutex_t defaults_mutex = PTHREAD_MUTEX_INITIALIZER;
+
 #ifdef WITH_SASL
 static int set_env(unsigned logopt, const char *name, const char *val)
 {
@@ -2935,17 +2937,13 @@ static int read_one_map(struct autofs_po
 	return NSS_STATUS_SUCCESS;
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
+	struct map_source *source = map;
 	int rv = LDAP_SUCCESS;
 	int ret, cur_state;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cur_state);
 	ret = read_one_map(ap, source, ctxt, age, &rv);
 	if (ret != NSS_STATUS_SUCCESS) {
@@ -3558,7 +3556,7 @@ static int check_map_indirect(struct aut
 
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cur_state);
 
-	status = pthread_mutex_lock(&ap->entry->current_mutex);
+	status = pthread_mutex_lock(&defaults_mutex);
 	if (status)
 		fatal(status);
 	if (is_amd_format) {
@@ -3580,7 +3578,7 @@ static int check_map_indirect(struct aut
 				ctxt->check_defaults = 0;
 		}
 	}
-	status = pthread_mutex_unlock(&ap->entry->current_mutex);
+	status = pthread_mutex_unlock(&defaults_mutex);
 	if (status)
 		fatal(status);
 
@@ -3627,12 +3625,12 @@ static int check_map_indirect(struct aut
 		}
 		cache_unlock(mc);
 
-		status = pthread_mutex_lock(&ap->entry->current_mutex);
+		status = pthread_mutex_lock(&defaults_mutex);
 		if (status)
 			fatal(status);
 		if (t_last_read > ap->exp_runfreq && ret & CHE_UPDATED)
 			source->stale = 1;
-		status = pthread_mutex_unlock(&ap->entry->current_mutex);
+		status = pthread_mutex_unlock(&defaults_mutex);
 		if (status)
 			fatal(status);
 	}
@@ -3648,11 +3646,11 @@ static int check_map_indirect(struct aut
 	return NSS_STATUS_SUCCESS;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	struct mapent *me;
 	char key[KEY_MAX_LEN + 1];
 	int key_len;
@@ -3663,12 +3661,6 @@ int lookup_mount(struct autofs_point *ap
 	int status = 0;
 	int ret = 1;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	debug(ap->logopt, MODPREFIX "looking up %s", name);
 
 	if (!(source->flags & MAP_FLAG_FORMAT_AMD)) {
@@ -3815,10 +3807,7 @@ int lookup_mount(struct autofs_point *ap
 
 	free(lkp_key);
 
-	master_source_current_wait(ap->entry);
-	ap->entry->current = source;
-
-	ret = ctxt->parse->parse_mount(ap, key, key_len,
+	ret = ctxt->parse->parse_mount(ap, source, key, key_len,
 				       mapent, ctxt->parse->context);
 	if (ret) {
 		/* Don't update negative cache when re-connecting */
--- autofs-5.1.4.orig/modules/lookup_multi.c
+++ autofs-5.1.4/modules/lookup_multi.c
@@ -525,20 +525,14 @@ int lookup_read_master(struct master *ma
         return NSS_STATUS_UNKNOWN;
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
+	struct map_source *source = map;
 	int i, ret, at_least_1 = 0;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
 	for (i = 0; i < ctxt->n; i++) {
-		master_source_current_wait(ap->entry);
-		ap->entry->current = source;
-		ret = ctxt->m[i].mod->lookup_read_map(ap, age,
+		ret = ctxt->m[i].mod->lookup_read_map(ap, source, age,
 						ctxt->m[i].mod->context);
 		if (ret & LKP_FAIL || ret == LKP_NOTSUP)
 			continue;
@@ -552,20 +546,14 @@ int lookup_read_map(struct autofs_point
 	return NSS_STATUS_SUCCESS;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
+	struct map_source *source = map;
 	int i;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
 	for (i = 0; i < ctxt->n; i++) {
-		master_source_current_wait(ap->entry);
-		ap->entry->current = source;
-		if (ctxt->m[i].mod->lookup_mount(ap, name, name_len,
+		if (ctxt->m[i].mod->lookup_mount(ap, source, name, name_len,
 						 ctxt->m[i].mod->context) == 0)
 			return NSS_STATUS_SUCCESS;
 	}
--- autofs-5.1.4.orig/modules/lookup_nisplus.c
+++ autofs-5.1.4/modules/lookup_nisplus.c
@@ -220,11 +220,11 @@ int lookup_read_master(struct master *ma
 	return NSS_STATUS_SUCCESS;
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	char *tablename;
 	nis_result *result;
 	nis_object *this;
@@ -233,10 +233,6 @@ int lookup_read_map(struct autofs_point
 	char buf[MAX_ERR_BUF];
 	int cur_state;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
 	/*
 	 * If we don't need to create directories (or don't need
 	 * to read an amd cache:=all map) then there's no use
@@ -670,11 +666,11 @@ static int check_map_indirect(struct aut
 	return NSS_STATUS_SUCCESS;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	char key[KEY_MAX_LEN + 1];
 	int key_len;
 	char *lkp_key;
@@ -685,12 +681,6 @@ int lookup_mount(struct autofs_point *ap
 	int status;
 	int ret = 1;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	debug(ap->logopt, MODPREFIX "looking up %s", name);
 
 	if (!(source->flags & MAP_FLAG_FORMAT_AMD)) {
@@ -839,10 +829,7 @@ int lookup_mount(struct autofs_point *ap
 
 	free(lkp_key);
 
-	master_source_current_wait(ap->entry);
-	ap->entry->current = source;
-
-	ret = ctxt->parse->parse_mount(ap, key, key_len,
+	ret = ctxt->parse->parse_mount(ap, source, key, key_len,
 				       mapent, ctxt->parse->context);
 	if (ret) {
 		free(mapent);
--- autofs-5.1.4.orig/modules/lookup_program.c
+++ autofs-5.1.4/modules/lookup_program.c
@@ -166,11 +166,8 @@ int lookup_read_master(struct master *ma
         return NSS_STATUS_UNKNOWN;
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
 	return NSS_STATUS_UNKNOWN;
 }
 
@@ -580,21 +577,15 @@ static int match_key(struct autofs_point
 	return ret;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	char *mapent = NULL;
 	struct mapent *me;
 	int ret = 1;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	/* Check if we recorded a mount fail for this key anywhere */
 	me = lookup_source_mapent(ap, name, LKP_DISTINCT);
 	if (me) {
@@ -662,10 +653,9 @@ int lookup_mount(struct autofs_point *ap
 				strcpy(ent, me->mapent);
 			}
 			cache_unlock(mc);
-			master_source_current_wait(ap->entry);
-			ap->entry->current = source;
-			ret = ctxt->parse->parse_mount(ap, name,
-				 name_len, ent, ctxt->parse->context);
+			ret = ctxt->parse->parse_mount(ap, source,
+						       name, name_len, ent,
+						       ctxt->parse->context);
 			if (ent)
 				free(ent);
 			goto out_free;
@@ -697,10 +687,7 @@ int lookup_mount(struct autofs_point *ap
 
 	debug(ap->logopt, MODPREFIX "%s -> %s", name, mapent);
 
-	master_source_current_wait(ap->entry);
-	ap->entry->current = source;
-
-	ret = ctxt->parse->parse_mount(ap, name, name_len,
+	ret = ctxt->parse->parse_mount(ap, source, name, name_len,
 				       mapent, ctxt->parse->context);
 out_free:
 	if (mapent)
--- autofs-5.1.4.orig/modules/lookup_sss.c
+++ autofs-5.1.4/modules/lookup_sss.c
@@ -771,23 +771,17 @@ int lookup_read_master(struct master *ma
 	return NSS_STATUS_SUCCESS;
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	void *sss_ctxt = NULL;
 	char *key;
 	char *value = NULL;
 	char *s_key;
 	int count, ret;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	/*
 	 * If we don't need to create directories (or don't need
 	 * to read an amd cache:=all map) then there's no use
@@ -873,11 +867,10 @@ int lookup_read_map(struct autofs_point
 	return NSS_STATUS_SUCCESS;
 }
 
-static int lookup_one(struct autofs_point *ap,
-		char *qKey, int qKey_len, struct lookup_context *ctxt)
+static int lookup_one(struct autofs_point *ap, struct map_source *source,
+		      char *qKey, int qKey_len, struct lookup_context *ctxt)
 {
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct mapent_cache *mc = source->mc;
 	struct mapent *we;
 	void *sss_ctxt = NULL;
 	time_t age = monotonic_time(NULL);
@@ -885,12 +878,6 @@ static int lookup_one(struct autofs_poin
 	char *s_key;
 	int err, ret;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	ret = setautomntent(ap->logopt, ctxt, &sss_ctxt, SSS_LOOKUP_KEY);
 	if (ret)
 		return ret;
@@ -983,24 +970,14 @@ wild:
 }
 
 static int check_map_indirect(struct autofs_point *ap,
-			      char *key, int key_len,
+			      struct map_source *source, char *key, int key_len,
 			      struct lookup_context *ctxt)
 {
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct mapent_cache *mc = source->mc;
 	int ret, cur_state;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
-	master_source_current_wait(ap->entry);
-	ap->entry->current = source;
-
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cur_state);
-	ret = lookup_one(ap, key, key_len, ctxt);
+	ret = lookup_one(ap, source, key, key_len, ctxt);
 	if (ret == NSS_STATUS_NOTFOUND) {
 		pthread_setcancelstate(cur_state, NULL);
 		return ret;
@@ -1026,11 +1003,11 @@ static int check_map_indirect(struct aut
 	return NSS_STATUS_SUCCESS;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	struct mapent *me;
 	char key[KEY_MAX_LEN + 1];
 	int key_len;
@@ -1038,12 +1015,6 @@ int lookup_mount(struct autofs_point *ap
 	char mapent_buf[MAPENT_MAX_LEN + 1];
 	int ret;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	debug(ap->logopt, MODPREFIX "looking up %s", name);
 
 	key_len = snprintf(key, KEY_MAX_LEN + 1, "%s", name);
@@ -1096,10 +1067,7 @@ int lookup_mount(struct autofs_point *ap
 		if (!lkp_key)
 			return NSS_STATUS_UNKNOWN;
 
-		master_source_current_wait(ap->entry);
-		ap->entry->current = source;
-
-		status = check_map_indirect(ap, lkp_key, strlen(lkp_key), ctxt);
+		status = check_map_indirect(ap, source, lkp_key, strlen(lkp_key), ctxt);
 		free(lkp_key);
 		if (status)
 			return status;
@@ -1146,11 +1114,9 @@ int lookup_mount(struct autofs_point *ap
 	if (!mapent)
 		return NSS_STATUS_TRYAGAIN;
 
-	master_source_current_wait(ap->entry);
-	ap->entry->current = source;
-
 	debug(ap->logopt, MODPREFIX "%s -> %s", key, mapent);
-	ret = ctxt->parse->parse_mount(ap, key, key_len,
+
+	ret = ctxt->parse->parse_mount(ap, source, key, key_len,
 				       mapent, ctxt->parse->context);
 	if (ret) {
 		/* Don't update negative cache when re-connecting */
--- autofs-5.1.4.orig/modules/lookup_userhome.c
+++ autofs-5.1.4/modules/lookup_userhome.c
@@ -46,27 +46,19 @@ int lookup_read_master(struct master *ma
         return NSS_STATUS_UNKNOWN;
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
 	return NSS_STATUS_UNKNOWN;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	struct passwd *pw;
 	char buf[MAX_ERR_BUF];
 	int ret;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	debug(ap->logopt, MODPREFIX "looking up %s", name);
 
 	/* Get the equivalent username */
--- autofs-5.1.4.orig/modules/lookup_yp.c
+++ autofs-5.1.4/modules/lookup_yp.c
@@ -59,6 +59,8 @@ struct callback_data {
 
 int lookup_version = AUTOFS_LOOKUP_VERSION;	/* Required by protocol */
 
+static pthread_mutex_t defaults_mutex = PTHREAD_MUTEX_INITIALIZER;
+
 static unsigned int get_map_order(const char *domain, const char *map)
 {
 	char key[] = "YP_LAST_MODIFIED";
@@ -392,20 +394,16 @@ int yp_all_callback(int status, char *yp
 	return 0;
 }
 
-int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
+int lookup_read_map(struct autofs_point *ap, struct map_source *map, time_t age, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
 	struct ypall_callback ypcb;
 	struct callback_data ypcb_data;
 	unsigned int logopt = ap->logopt;
-	struct map_source *source;
+	struct map_source *source = map;
 	char *mapname;
 	int err;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
 	/*
 	 * If we don't need to create directories (or don't need
 	 * to read an amd cache:=all map) then there's no use
@@ -457,9 +455,9 @@ int lookup_read_map(struct autofs_point
 	}
 
 	source->age = age;
-	pthread_mutex_lock(&ap->entry->current_mutex);
+	pthread_mutex_lock(&defaults_mutex);
 	ctxt->check_defaults = 0;
-	pthread_mutex_unlock(&ap->entry->current_mutex);
+	pthread_mutex_unlock(&defaults_mutex);
 
 	return NSS_STATUS_SUCCESS;
 }
@@ -685,7 +683,7 @@ static int check_map_indirect(struct aut
 	mc = source->mc;
 
 	/* Only read map if it has been modified */
-	pthread_mutex_lock(&ap->entry->current_mutex);
+	pthread_mutex_lock(&defaults_mutex);
 	map_order = get_map_order(ctxt->domainname, ctxt->mapname);
 	if (map_order > ctxt->order) {
 		ctxt->order = map_order;
@@ -702,7 +700,7 @@ static int check_map_indirect(struct aut
 		} else
 			ctxt->check_defaults = 0;
 	}
-	pthread_mutex_unlock(&ap->entry->current_mutex);
+	pthread_mutex_unlock(&defaults_mutex);
 
 	/* check map and if change is detected re-read map */
 	ret = match_key(ap, source, key, key_len, ctxt);
@@ -782,11 +780,11 @@ static int check_map_indirect(struct aut
 	return NSS_STATUS_SUCCESS;
 }
 
-int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *context)
+int lookup_mount(struct autofs_point *ap, struct map_source *map, const char *name, int name_len, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	char key[KEY_MAX_LEN + 1];
 	int key_len;
 	char *lkp_key;
@@ -797,12 +795,6 @@ int lookup_mount(struct autofs_point *ap
 	int status = 0;
 	int ret = 1;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	debug(ap->logopt, MODPREFIX "looking up %s", name);
 
 	if (!(source->flags & MAP_FLAG_FORMAT_AMD)) {
@@ -957,10 +949,7 @@ int lookup_mount(struct autofs_point *ap
 
 	free(lkp_key);
 
-	master_source_current_wait(ap->entry);
-	ap->entry->current = source;
-
-	ret = ctxt->parse->parse_mount(ap, key, key_len,
+	ret = ctxt->parse->parse_mount(ap, source, key, key_len,
 				       mapent, ctxt->parse->context);
 	free(mapent);
 	if (ret) {
--- autofs-5.1.4.orig/modules/parse_amd.c
+++ autofs-5.1.4/modules/parse_amd.c
@@ -1383,12 +1383,9 @@ static int do_host_mount(struct autofs_p
 		cache_push_mapent(me, NULL);
 	cache_unlock(source->mc);
 
-	master_source_current_wait(ap->entry);
-	ap->entry->current = instance;
-
 	map_module_readlock(instance);
 	lookup = instance->lookup;
-	ret = lookup->lookup_mount(ap, entry->rhost,
+	ret = lookup->lookup_mount(ap, instance, entry->rhost,
 				   strlen(entry->rhost), lookup->context);
 	map_module_unlock(instance);
 
@@ -2203,13 +2200,14 @@ done:
 	return defaults_entry;
 }
 
-int parse_mount(struct autofs_point *ap, const char *name,
-		int name_len, const char *mapent, void *context)
+int parse_mount(struct autofs_point *ap, struct map_source *map,
+		const char *name, int name_len, const char *mapent,
+		void *context)
 {
 	struct parse_context *ctxt = (struct parse_context *) context;
 	unsigned int flags = conf_amd_get_flags(ap->path);
 	struct substvar *sv = NULL;
-	struct map_source *source;
+	struct map_source *source = map;
 	unsigned int at_least_one;
 	struct list_head entries, *p, *head;
 	struct amd_entry *defaults_entry;
@@ -2219,10 +2217,6 @@ int parse_mount(struct autofs_point *ap,
 	int cur_state;
 	int ret;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
 	if (!mapent) {
 		warn(ap->logopt, MODPREFIX "error: empty map entry");
 		return 1;
--- autofs-5.1.4.orig/modules/parse_hesiod.c
+++ autofs-5.1.4/modules/parse_hesiod.c
@@ -272,8 +272,9 @@ int parse_done(void *context)
 	return 0;
 }
 
-int parse_mount(struct autofs_point *ap, const char *name,
-		int name_len, const char *mapent, void *context)
+int parse_mount(struct autofs_point *ap, struct map_source *map,
+		const char *name, int name_len, const char *mapent,
+		void *context)
 {
 	char source[HESIOD_LEN + 1];
 	char fstype[HESIOD_LEN + 1];
@@ -282,9 +283,6 @@ int parse_mount(struct autofs_point *ap,
 	const char *p;
 	int ret;
 
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
 	p = mapent;
 	q = fstype;
 
--- autofs-5.1.4.orig/modules/parse_sun.c
+++ autofs-5.1.4/modules/parse_sun.c
@@ -1309,13 +1309,14 @@ static void cleanup_offset_entries(struc
  * level nexting point. Finally to mount non multi-mounts and to mount a
  * lower level multi-mount nesting point and its offsets.
  */
-int parse_mount(struct autofs_point *ap, const char *name,
-		int name_len, const char *mapent, void *context)
+int parse_mount(struct autofs_point *ap, struct map_source *map,
+		const char *name, int name_len, const char *mapent,
+		void *context)
 {
 	struct parse_context *ctxt = (struct parse_context *) context;
 	char buf[MAX_ERR_BUF];
-	struct map_source *source;
-	struct mapent_cache *mc;
+	struct map_source *source = map;
+	struct mapent_cache *mc = source->mc;
 	struct mapent *me, *oe, *tmp;
 	LIST_HEAD(offsets);
 	char *pmapent, *options;
@@ -1325,12 +1326,6 @@ int parse_mount(struct autofs_point *ap,
 	int slashify = ctxt->slashify_colons;
 	unsigned int append_options;
 
-	source = ap->entry->current;
-	ap->entry->current = NULL;
-	master_source_current_signal(ap->entry);
-
-	mc = source->mc;
-
 	if (!mapent) {
 		warn(ap->logopt, MODPREFIX "error: empty map entry");
 		return 1;
