autofs-5.1.8 - dont take parent source lock at mount shutdown

From: Ian Kent <raven@themaw.net>

There shouldn't be any need to take the parent source lock at autofs mount
shutdown so don't take it.

Signed-off-by: Ian Kent <raven@themaw.net>
---
 CHANGELOG          |    1 
 daemon/automount.c |   60 ++---------------------------------------------------
 2 files changed, 4 insertions(+), 57 deletions(-)

--- autofs-5.1.4.orig/CHANGELOG
+++ autofs-5.1.4/CHANGELOG
@@ -139,6 +139,7 @@
 - set mapent dev and ino before adding to index.
 - change to use printf functions in amd parser.
 - dont call umount_subtree_mounts() on parent at umount.
+- dont take parent source lock at mount shutdown.
 
 xx/xx/2018 autofs-5.1.5
 - fix flag file permission.
--- autofs-5.1.4.orig/daemon/automount.c
+++ autofs-5.1.4/daemon/automount.c
@@ -1761,7 +1761,6 @@ static void handle_mounts_cleanup(void *
 	 * here.
 	 */
 	if (submount) {
-		master_source_unlock(ap->parent->entry);
 		master_free_mapent_sources(ap->entry, 1);
 		master_free_mapent(ap->entry);
 	}
@@ -1789,36 +1788,6 @@ static void handle_mounts_cleanup(void *
 	return;
 }
 
-static int submount_source_writelock_nested(struct autofs_point *ap)
-{
-	struct autofs_point *parent = ap->parent;
-	int status;
-
-	status = pthread_rwlock_trywrlock(&parent->entry->source_lock);
-	if (status)
-		goto done;
-
-	status = pthread_rwlock_trywrlock(&ap->entry->source_lock);
-	if (status)
-		master_source_unlock(parent->entry);
-
-done:
-	if (status && status != EBUSY) {
-		logmsg("submount nested master_mapent source write lock failed");
-		fatal(status);
-	}
-
-	return status;
-}
-
-static void submount_source_unlock_nested(struct autofs_point *ap)
-{
-	struct autofs_point *parent = ap->parent;
-
-	master_source_unlock(ap->entry);
-	master_source_unlock(parent->entry);
-}
-
 int handle_mounts_exit(struct autofs_point *ap)
 {
 	int ret, cur_state;
@@ -1833,33 +1802,13 @@ int handle_mounts_exit(struct autofs_poi
 
 	master_mutex_lock();
 
-	if (!ap->submount)
-		master_source_writelock(ap->entry);
-	else {
-		/*
-		 * If a mount request arrives before the locks are
-		 * aquired just return to ready state.
-		 */
-		ret = submount_source_writelock_nested(ap);
-		if (ret) {
-			warn(ap->logopt,
-			     "can't shutdown submount: mount in progress");
-			/* Return to ST_READY is done immediately */
-			st_add_task(ap, ST_READY);
-			master_mutex_unlock();
-			pthread_setcancelstate(cur_state, NULL);
-			return 0;
-		}
-	}
+	master_source_writelock(ap->entry);
 
 	if (ap->state != ST_SHUTDOWN) {
 		conditional_alarm_add(ap, ap->exp_runfreq);
 		/* Return to ST_READY is done immediately */
 		st_add_task(ap, ST_READY);
-		if (ap->submount)
-			submount_source_unlock_nested(ap);
-		else
-			master_source_unlock(ap->entry);
+		master_source_unlock(ap->entry);
 		master_mutex_unlock();
 
 		pthread_setcancelstate(cur_state, NULL);
@@ -1900,10 +1849,7 @@ int handle_mounts_exit(struct autofs_poi
 	conditional_alarm_add(ap, ap->exp_runfreq);
 	/* Return to ST_READY is done immediately */
 	st_add_task(ap, ST_READY);
-	if (ap->submount)
-		submount_source_unlock_nested(ap);
-	else
-		master_source_unlock(ap->entry);
+	master_source_unlock(ap->entry);
 	master_mutex_unlock();
 
 	pthread_setcancelstate(cur_state, NULL);
